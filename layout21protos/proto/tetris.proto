
//! 
//! # vlsir "Tetris" Gridded Layout Schema 
//! 
//! Remains work-in-progress as of this writing 
//! 

syntax = "proto3";
package vlsir.tetris;

import "utils.proto";
import "raw.proto";
import "views.proto";


// // # Library 
// // A collection of `Cells` and asssociated metadata. 
// message Library {
//   // Library Name / Domain 
//   string domain = 1;
//   // Distance Units
//   vlsir.raw.Units units = 2;
//   // Cell Definitions
//   repeated Cell cells = 10; 
// }

// // # Cell 
// // A multi-view representation of a piece of hardware.
// message Cell {
//   // Cell Name
//   string name = 1;
//   // IO Interface
//   vlsir.raw.Interface interface = 10;
//   // Physical Abstrakt
//   Abstrakt abstrakt = 11;
//   // Physical Layout Implementation
//   Layout layout = 12;
// }

// # Layout 
// 
// Physical implementation of a `Cell`. Tetris layouts consist of: 
// * `Instances` of other `Cells`, 
// * Net-assignments at grid crossings, and 
// * Cuts of the grid 
// (That's all.) 
// 
// `Layouts` have an explicit `Outline`, in which all their attributes must fit, 
// and into which no other `Layout` can encroach. 
// This operates similarly to "blockage" on all layers in legacy layout systems. 
// 
message Layout {
  // Cell Name
  string name = 1;
  
  // Outline 
  Outline outline = 10;

  // Layout Instances
  repeated Instance instances = 20;
  // Net-to-track assignments
  repeated Assign assigns = 21;
  // Track cuts
  repeated TrackCross cuts = 22;
}

// # Assignment 
// 
// Assigns signal `net` to the two tracks crossing in location `at`. 
// Tetris signal-assignments are to track-crosses. 
// This operates much like assigning to a via, plus the tracks above and below. 
message Assign {
  // Net Name
  string net = 1;
  // Location
  TrackCross at = 2;
}

// # Track Cross
// Crossing between two `TrackRefs`
message TrackCross {
  TrackRef top = 1;
  TrackRef bot = 2;
}

// # Track Reference
// Pointer to a layer-index and track-index 
message TrackRef {
  int64 layer = 1;
  int64 index = 2;
}

// # Cell Outlines
// ## "Tetris Shaped" rectilinear polygons
//
// These boundaries are closed, consist solely of 90-degree rectangular turns,
// and are specified by a counter-clockwise set of points.
// "Holes" such as the shapes "O" and "8" and "divots" such as the shapes "U" and "H" are not supported.
// The z-axis top is uniform and specified by a single layer-index `top_layer`. 
//
// Two equal-length vectors `x` and `y` describe an Outline's (x, y) points.
// Counter-clockwise-ness and divot-free-ness requires that:
// * (a) `x` values are monotonically non-increasing, and
// * (b) `y` values are monotonically non-decreasing
//
// In point-space terms, such an outline has vertices at:
// `[(0,0), (x[0], 0), (x[0], y[0]), (x[1], y[0]), ... , (0, y[-1]), (0,0)]`
// With the final point at (0, y[-1]), and its connection back to the origin both implied.
//
// Example: a rectangular Outline would require a single entry for each of `x` and `y`,
// at the rectangle's vertex opposite the origin in both axes.
//
message Outline {
  // X Coordinates
  repeated vlsir.raw.Point x = 1;
  // Y Coordinates
  repeated vlsir.raw.Point y = 2;
  // Top-layer index
  int64 top_layer = 3;
}

// # Abstrakt Layout 
// 
// Defines the physical interface to a [Cell], including ports and internal blockages, 
// omitting internal implementation details.
message Abstrakt {
  // Cell Name
  string name = 1;
  // Outline 
  Outline outline = 10;
  // Ports 
  repeated AbstraktPort ports = 20; 
}

// # Abstrakt Port
// Combination of a net and set of shapes
message AbstraktPort {
  // Port Name
  string net = 1;
  // Enumerated port types
  oneof kind {
    // Edge 
    EdgePort edge = 10;
    // Z-Top, at Edge 
    ZTopEdgePort ztop_edge = 11;
    // Z-Top, inside Outline 
    ZTopInner ztop_inner = 12;
  }
}

// # Edge Port
// On a layer less than `top_layer`. Only connectable on its `track` and `side`.
message EdgePort { 
  TrackRef track = 1;
  PortSide side = 2;
}
// # Z-Top, on Edge Port
// Can be connected from either `top_layer+1`, or the edge on `top_layer`. 
message ZTopEdgePort { 
  // Track index
  int64 track = 1;
  // Side
  PortSide side = 2;
  // Extent into the cell. 
  // Must be a location which intersects with (track, Side) inside the Outline.
  TrackCross into = 3;
}
// # Z-Top, inside Outline Port
message ZTopInner { 
  // Locations. All must be on layers adjacent to the top-layer.
  repeated TrackCross locs = 1;
}

// # Abstrakt Port Side 
// 
// A two-value enum, as each layer either runs horizontally or vertically. 
// Ports on the nearer-origin (bottom or left) sides use variant `BOTTOM_OR_LEFT`, 
// while ports on the opposite sides use `TOP_OR_RIGHT`. 
enum PortSide {
  BOTTOM_OR_LEFT = 0;
  TOP_OR_RIGHT = 1;
}

// # Cell Instance
message Instance {
  // Instance Name
  string name = 1;
  // Cell Reference
  vlsir.utils.Reference cell = 3;
  
  // Location of the defined Cell's origin 
  // this location holds regardless of reflection settings.
  Place loc = 4; 
  // Horizontal reflection about y-axis
  bool reflect_horiz = 6;
  // Vertical reflection about x-axis
  bool reflect_vert = 7;
}

// # Place 
// An absolute or relative placement description
message Place {
  oneof place {
    // Absolute 
    vlsir.raw.Point abs = 1;
    // Relative 
    RelPlace rel = 2;
  }
}

// # Relative Place
// FIXME! 
message RelPlace { } 

